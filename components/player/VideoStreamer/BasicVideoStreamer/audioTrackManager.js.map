{"version":3,"sources":["../../../../src/replay/components/player/VideoStreamer/BasicVideoStreamer/audioTrackManager.js"],"names":["id","createManagedTrack","videoElementTrack","selectableTrack","language","kind","label","origin","getAudioTrackManager","videoElement","update","managedTracks","mapAudioTracks","audioTracks","Array","from","map","updateStreamStateProps","selectedTrack","currentAudioTrack","filter","mt","enabled","handleTrackAddOrRemove","handleTrackChange","setup","addEventListener","handleSourceChange","handleSelectedAudioTrackChange","selectedAudioTrack","managedTrack","cleanup","removeEventListener"],"mappings":"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","sourcesContent":["// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { AudioTrackManager } from '../common/types';\n\n// http://sample.vodobox.com/planete_interdite/planete_interdite_alternate.m3u8\n\n/*export type AudioTracksStateProps = {\n  audioTracks?: Array<AvailableTrack>,\n  currentAudioTrack?: ?AvailableTrack\n};*/\n\ntype ManagedAudioTrack = {\n  videoElementTrack: AudioTrack,\n  selectableTrack: AvailableTrack\n};\n\nlet id = 0;\n\nconst createManagedTrack = (videoElementTrack: AudioTrack): ManagedAudioTrack => {\n  return {\n    selectableTrack: {\n      id: videoElementTrack.id == null ? `audio-${++id}` : videoElementTrack.id,\n      language: videoElementTrack.language || '',\n      kind: videoElementTrack.kind || '',\n      label: videoElementTrack.label || '',\n      origin: 'in-stream'\n    },\n    videoElementTrack\n  };\n};\n\nconst getAudioTrackManager = (videoElement: HTMLVideoElement, update: VideoStreamState => void): AudioTrackManager => {\n  let managedTracks: Array<ManagedAudioTrack> = [];\n\n  function mapAudioTracks() {\n    // $FlowFixMe Array.from() doesn't seem to understand iterables from the DOM API.\n    managedTracks = videoElement.audioTracks ? Array.from(videoElement.audioTracks).map(createManagedTrack) : [];\n  }\n\n  function updateStreamStateProps(selectedTrack?: ?AvailableTrack) {\n    const currentAudioTrack =\n      selectedTrack ||\n      managedTracks.filter(mt => mt.videoElementTrack.enabled).map(mt => mt.selectableTrack)[0] ||\n      null;\n    // TODO: Don't create a new array with new items every time. A deep equal comparison on availableTracks is needed.\n    update({ audioTracks: managedTracks.map(mt => mt.selectableTrack), currentAudioTrack });\n  }\n\n  function handleTrackAddOrRemove() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleTrackChange() {\n    updateStreamStateProps();\n  }\n\n  function setup() {\n    if (videoElement.audioTracks) {\n      videoElement.audioTracks.addEventListener('addtrack', handleTrackAddOrRemove);\n      videoElement.audioTracks.addEventListener('change', handleTrackChange);\n      videoElement.audioTracks.addEventListener('removetrack', handleTrackAddOrRemove);\n    }\n    handleSourceChange();\n  }\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedAudioTrack)[0];\n    if (managedTrack) {\n      managedTrack.videoElementTrack.enabled = true;\n    }\n  }\n\n  function cleanup() {\n    if (videoElement.audioTracks) {\n      videoElement.audioTracks.removeEventListener('addtrack', handleTrackAddOrRemove);\n      videoElement.audioTracks.removeEventListener('change', handleTrackChange);\n      videoElement.audioTracks.removeEventListener('removetrack', handleTrackAddOrRemove);\n    }\n    managedTracks = [];\n  }\n\n  function handleSourceChange() {\n    handleTrackAddOrRemove();\n  }\n\n  setup();\n\n  return {\n    cleanup,\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getAudioTrackManager;\n"],"file":"audioTrackManager.js"}