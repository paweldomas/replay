{"version":3,"sources":["../../../../src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaAudioTrackManager.js"],"names":["createManagedTrack","language","role","index","selectableTrack","id","kind","label","origin","isTrackMatchingLanguageAndRole","shakaTrack","roles","indexOf","getShakaAudioTrackManager","shakaPlayer","updateStreamState","managedTracks","updateCurrentAudioTrack","activeShakaTrack","getVariantTracks","filter","track","active","currentAudioTrack","mt","map","updateAudioTracks","getAudioLanguagesAndRoles","audioTracks","shakaEventHandlers","loading","trackschanged","adaptation","handleSelectedAudioTrackChange","selectedAudioTrack","managedTrack","selectAudioLanguage","handleSourceChange","length","cleanup","Object","entries","forEach","name","handler","removeEventListener","addEventListener"],"mappings":"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","sourcesContent":["// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { ShakaLanguageRole, ShakaPlayer, ShakaTrack } from './types';\nimport type { AudioTrackManager } from '../common/types';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype ManagedAudioTrack = {\n  language: string,\n  role: string,\n  selectableTrack: AvailableTrack\n};\n\nconst createManagedTrack = ({ language, role }: ShakaLanguageRole, index: number): ManagedAudioTrack => {\n  return {\n    selectableTrack: {\n      id: language + role || index,\n      kind: role,\n      label: '',\n      language: language,\n      origin: 'in-stream'\n    },\n    language,\n    role\n  };\n};\n\nconst isTrackMatchingLanguageAndRole = (shakaTrack: ShakaTrack, { language, role }: ShakaLanguageRole) => {\n  return shakaTrack.language === language && (!role || (shakaTrack.roles && shakaTrack.roles.indexOf(role) >= 0));\n};\n\nconst getShakaAudioTrackManager = (\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void\n): AudioTrackManager => {\n  let managedTracks: Array<ManagedAudioTrack> = [];\n\n  function updateCurrentAudioTrack() {\n    const activeShakaTrack = shakaPlayer.getVariantTracks().filter(track => track.active)[0];\n    const currentAudioTrack =\n      activeShakaTrack &&\n      managedTracks.filter(mt => isTrackMatchingLanguageAndRole(activeShakaTrack, mt)).map(mt => mt.selectableTrack)[0];\n    updateStreamState({ currentAudioTrack });\n  }\n\n  function updateAudioTracks() {\n    managedTracks = shakaPlayer.getAudioLanguagesAndRoles().map(createManagedTrack);\n    const audioTracks = managedTracks.map(mt => mt.selectableTrack);\n    updateStreamState({\n      audioTracks\n    });\n    updateCurrentAudioTrack();\n  }\n\n  const shakaEventHandlers = {\n    loading: updateAudioTracks,\n    trackschanged: updateAudioTracks,\n    adaptation: updateCurrentAudioTrack\n  };\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedAudioTrack)[0];\n    if (managedTrack) {\n      shakaPlayer.selectAudioLanguage(managedTrack.language, managedTrack.role);\n      updateCurrentAudioTrack();\n    }\n  }\n\n  function handleSourceChange() {\n    managedTracks.length = 0;\n  }\n\n  function cleanup() {\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  return {\n    cleanup,\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getShakaAudioTrackManager;\n"],"file":"shakaAudioTrackManager.js"}