{"version":3,"sources":["../../../../src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaTextTrackManager.js"],"names":["isEqual","a","b","Number","isNaN","trackPropKeys","isShakaTrackEqual","filter","key","length","createSelectableTrack","id","origin","shakaTrack","kind","label","language","supportedContentTypes","isContentTypeSupported","sourceTrack","contentType","ct","indexOf","getShakaTextTrackManager","shakaPlayer","updateStreamState","managedTextTracks","selectableTextTracks","emptyTracks","getActiveShakaTrack","getTextTracks","track","active","update","allProps","currentTextTrack","selectedTrack","isTextTrackVisible","e","managedSelectedTrack","managedTrack","isBlacklisted","selectableTrack","textTracks","m","map","emptyManagedTextTrackList","ingestAndFilterEarlierAddedTracks","sourceTracks","managedTrackMatches","managedTextTrack","src","addedTrack","isLoaded","error","loadPromise","Promise","resolve","updateManagedTrackListFromAddedTracks","tracksBeingAdded","newManagedTracks","trackBeingAdded","shakaLoadPromise","addPromise","then","Error","concat","all","nmt","selectShakaTrack","removeEventListener","shakaEventHandlers","texttrackvisibility","setTextTrackVisibility","window","setTimeout","fullShakaTrack","updatedTrack","selectTextTrack","addEventListener","addTracks","tracks","supportedTracks","trackschanged","freshTracks","charsetPos","substr","addTextTrackAsync","updateFromShakaTextTracks","shakaTracks","newManagedTrackList","equalTracks","isRemoving","isAdding","blacklistExistingSideLoadedTracks","forEach","handleSourcePropChange","props","newTracks","Array","isArray","source","handleTextTracksPropChange","clear","handleSelectedTextTrackChange","textTrack","mt","loading","cleanup","Object","entries","name","handler"],"mappings":"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","sourcesContent":["//@flow\nimport type { ShakaPlayer, ShakaTrack } from './types';\nimport type { AvailableTrack, PlaybackSource, SourceTrack, VideoStreamState } from '../types';\nimport { emptyTracks } from '../common/playbackLifeCycleManager';\nimport { isShallowEqual } from '../../../common';\nimport type { ManagedTextTrack } from '../BasicVideoStreamer/textTrackManager';\nimport type { TextTrackManager } from '../common/types';\nimport normalizeSource from '../common/sourceNormalizer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype ManagedShakaTextTrack = ManagedTextTrack & {\n  shakaTrack: ?ShakaTrack,\n  shakaLoadPromise?: Promise<?ShakaTrack>\n};\n\nfunction isEqual(a, b) {\n  return a === b || (a == null && b == null ? true : Number.isNaN(a) && Number.isNaN(b));\n}\n\nconst trackPropKeys = ['id', 'language', 'kind', 'label'];\n\nfunction isShakaTrackEqual(a, b) {\n  return (a && b && trackPropKeys.filter(key => isEqual(a[key], b[key])).length === trackPropKeys.length) || (!a && !b);\n}\n\nfunction createSelectableTrack(\n  id: number,\n  origin: 'in-stream' | 'side-loaded',\n  shakaTrack: ShakaTrack\n): AvailableTrack {\n  const kind = shakaTrack.kind === 'subtitle' ? 'subtitles' : shakaTrack.kind || '';\n  return {\n    id,\n    kind,\n    label: shakaTrack.label || '',\n    language: shakaTrack.language || '',\n    origin\n  };\n}\n\nconst supportedContentTypes = ['text/vtt', 'application/ttml+xml', 'text/srt'];\n\nfunction isContentTypeSupported(sourceTrack) {\n  const contentType = sourceTrack.contentType;\n  return contentType && supportedContentTypes.filter(ct => contentType.indexOf(ct) === 0).length > 0;\n}\n\nfunction getShakaTextTrackManager(\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void\n): TextTrackManager {\n  let managedTextTracks: Array<ManagedShakaTextTrack> = [];\n  let selectableTextTracks = emptyTracks;\n\n  function getActiveShakaTrack() {\n    return (shakaPlayer.getTextTracks() || []).filter(track => track.active)[0];\n  }\n\n  function update(allProps: boolean) {\n    let currentTextTrack = null;\n    let selectedTrack = null;\n    try {\n      // In case of errors, this might fail due to early cleanup.\n      selectedTrack = shakaPlayer.isTextTrackVisible() ? getActiveShakaTrack() : null;\n    } catch (e) {}\n    if (selectedTrack) {\n      const managedSelectedTrack = managedTextTracks.filter(\n        managedTrack =>\n          !managedTrack.isBlacklisted &&\n          managedTrack.selectableTrack != null &&\n          isShakaTrackEqual(managedTrack.shakaTrack, selectedTrack)\n      )[0];\n      currentTextTrack = managedSelectedTrack ? managedSelectedTrack.selectableTrack : null;\n    }\n    if (allProps) {\n      const textTracks = managedTextTracks.filter(m => m.selectableTrack).map(m => m.selectableTrack);\n      if (isShallowEqual(textTracks, selectableTextTracks)) {\n        // $FlowFixMe Complaints about null entries, despite filter above.\n        updateStreamState({\n          textTracks: selectableTextTracks,\n          currentTextTrack\n        });\n      } else {\n        selectableTextTracks = textTracks;\n        updateStreamState({\n          textTracks,\n          currentTextTrack\n        });\n      }\n    } else {\n      updateStreamState({\n        currentTextTrack\n      });\n    }\n  }\n\n  function emptyManagedTextTrackList() {\n    managedTextTracks.length = 0;\n    update(true);\n  }\n\n  function ingestAndFilterEarlierAddedTracks(sourceTracks: Array<SourceTrack>) {\n    return sourceTracks.filter(sourceTrack => {\n      const managedTrackMatches = managedTextTracks.filter(\n        managedTextTrack =>\n          managedTextTrack.sourceTrack &&\n          managedTextTrack.sourceTrack.src === sourceTrack.src &&\n          managedTextTrack.shakaTrack\n      );\n      if (managedTrackMatches.length === 0) {\n        return true;\n      } else {\n        const addedTrack = managedTrackMatches[0];\n        const shakaTrack = addedTrack.shakaTrack;\n        if (shakaTrack) {\n          addedTrack.sourceTrack = sourceTrack;\n          addedTrack.isBlacklisted = false;\n          addedTrack.isLoaded = true;\n          if (addedTrack.shakaTrack)\n            addedTrack.selectableTrack = createSelectableTrack(\n              addedTrack.shakaTrack.id,\n              'side-loaded',\n              addedTrack.shakaTrack\n            );\n          addedTrack.error = null;\n          addedTrack.loadPromise = Promise.resolve();\n          return false;\n        }\n        return false;\n      }\n    });\n  }\n\n  function updateManagedTrackListFromAddedTracks(tracksBeingAdded) {\n    const newManagedTracks = tracksBeingAdded.map(trackBeingAdded => {\n      const managedTrack: ManagedShakaTextTrack = {\n        id: null,\n        sourceTrack: trackBeingAdded.sourceTrack,\n        shakaTrack: null,\n        isBlacklisted: false, // When a track is explicitly added, we don't assume or check for duplicates, thus blacklisting should not be relevant.\n        isLoaded: false,\n        error: null,\n        selectableTrack: null,\n        shakaLoadPromise: trackBeingAdded.addPromise.then(\n          shakaTrack => {\n            managedTrack.isLoaded = true;\n            managedTrack.shakaTrack = shakaTrack;\n            managedTrack.selectableTrack = createSelectableTrack(shakaTrack.id, 'side-loaded', shakaTrack);\n            return shakaTrack;\n          },\n          error => {\n            managedTrack.error =\n              error || new Error('Shaka rejected adding a track with the URL ' + trackBeingAdded.sourceTrack.src);\n            managedTrack.isBlacklisted = true;\n            managedTrack.isLoaded = true;\n            return null;\n          }\n        )\n      };\n      return managedTrack;\n    });\n    managedTextTracks = managedTextTracks.concat(newManagedTracks);\n    return Promise.all(newManagedTracks.map(nmt => nmt.shakaLoadPromise));\n  }\n\n  function selectShakaTrack(shakaTrack: ?ShakaTrack) {\n    // setTextTrackVisibility() (and some other internal Shaka methods) is not dealing well with different text tracks having the same language code.\n    // This method needs to complete async tasks (promises?) before we can select the correct track.\n    if (shakaTrack) {\n      shakaPlayer.removeEventListener('texttrackvisibility', shakaEventHandlers.texttrackvisibility);\n      if (!shakaPlayer.isTextTrackVisible()) {\n        shakaPlayer.setTextTrackVisibility(true);\n      }\n      window.setTimeout(() => {\n        // Shaka tracks contain incomplete data and an updated version needs to be looked up:\n        const fullShakaTrack = (shakaPlayer.getTextTracks() || []).filter(updatedTrack => {\n          return isShakaTrackEqual(updatedTrack, shakaTrack);\n        })[0];\n        if (fullShakaTrack) {\n          shakaPlayer.selectTextTrack(fullShakaTrack);\n        } else {\n          shakaTrack && shakaPlayer.selectTextTrack(shakaTrack);\n        }\n        update(false);\n        shakaPlayer.addEventListener('texttrackvisibility', shakaEventHandlers.texttrackvisibility);\n      }, 1);\n    } else {\n      if (shakaPlayer.isTextTrackVisible()) {\n        shakaPlayer.setTextTrackVisibility(false);\n      }\n    }\n  }\n\n  function addTracks(tracks: Array<SourceTrack>) {\n    const supportedTracks = tracks.filter(isContentTypeSupported);\n\n    // We don't want updates to videoModel for each track during load.\n    shakaPlayer.removeEventListener('trackschanged', shakaEventHandlers.trackschanged);\n\n    // If the same source track was added earlier, and is readded, then just refurbish and un-blacklist the entry.\n    const freshTracks = ingestAndFilterEarlierAddedTracks(supportedTracks);\n    return updateManagedTrackListFromAddedTracks(\n      freshTracks.map(sourceTrack => {\n        let contentType = sourceTrack.contentType;\n        const charsetPos = contentType ? contentType.indexOf(';charset') : -1;\n        if (charsetPos > 0) {\n          contentType = contentType && contentType.substr(0, charsetPos);\n        }\n        return {\n          addPromise: shakaPlayer.addTextTrackAsync(\n            sourceTrack.src,\n            sourceTrack.language,\n            sourceTrack.kind,\n            contentType,\n            null,\n            sourceTrack.label\n          ),\n          sourceTrack: sourceTrack\n        };\n      })\n    ).then(() => {\n      // Now we are ready again for other track change events coming from the stream etc.\n      shakaPlayer.addEventListener('trackschanged', shakaEventHandlers.trackschanged);\n      update(true);\n    });\n  }\n\n  function updateFromShakaTextTracks() {\n    const shakaTracks = shakaPlayer.getTextTracks() || [];\n    //logger.debug('trackschanged fired.', shakaTracks);\n    if (shakaTracks.length === 0) {\n      // Don't spend CPU cycles comparing the old and new track list when the new list is empty.\n      /*if (managedTextTracks.length === 0) {\n        logger.debug('No Shaka text tracks reported.');\n      } else {\n        logger.debug('No Shaka text tracks reported. Emptying the list.');\n      }*/\n      emptyManagedTextTrackList();\n    } else {\n      // Keep existing managed tracks untouched. This includes blacklisting.\n      const newManagedTrackList = managedTextTracks.filter(managedTrack => {\n        const equalTracks = shakaTracks.filter(shakaTrack => isShakaTrackEqual(shakaTrack, managedTrack.shakaTrack));\n        return equalTracks.length === 1;\n      });\n\n      const isRemoving = newManagedTrackList.length < managedTextTracks.length;\n      const isAdding = shakaTracks.length > newManagedTrackList.length;\n\n      if (isAdding) {\n        const freshTracks = shakaTracks.filter(shakaTrack => {\n          const equalTracks = newManagedTrackList.filter(managedTrack =>\n            isShakaTrackEqual(shakaTrack, managedTrack.shakaTrack)\n          );\n          return equalTracks.length === 0;\n        });\n        const newManagedTracks = freshTracks.map(shakaTrack => ({\n          sourceTrack: null,\n          shakaTrack: shakaTrack,\n          isBlacklisted: false,\n          selectableTrack: createSelectableTrack(shakaTrack.id, 'in-stream', shakaTrack),\n          isLoaded: true,\n          error: null\n        }));\n        managedTextTracks = newManagedTrackList.concat(newManagedTracks);\n        update(true);\n      } else if (isRemoving) {\n        managedTextTracks = newManagedTrackList;\n        update(true);\n      }\n    }\n  }\n\n  function blacklistExistingSideLoadedTracks() {\n    const selectedTrack = shakaPlayer.isTextTrackVisible() ? getActiveShakaTrack() : null;\n    managedTextTracks\n      .filter(managedTrack => {\n        return managedTrack.sourceTrack != null;\n      })\n      .forEach(managedTrack => {\n        if (managedTrack.selectableTrack) {\n          managedTrack.selectableTrack = null;\n        }\n        if (\n          selectedTrack &&\n          managedTrack.shakaTrack &&\n          managedTrack.shakaTrack.active &&\n          isShakaTrackEqual(selectedTrack, managedTrack.shakaTrack)\n        ) {\n          shakaPlayer.setTextTrackVisibility(false);\n        }\n        managedTrack.isBlacklisted = true;\n      });\n  }\n\n  function handleSourcePropChange(props: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    let newTracks = Array.isArray(props.textTracks) ? props.textTracks : [];\n    const source = normalizeSource(props.source);\n    if (source && source.textTracks) {\n      addTracks(newTracks.concat(source.textTracks));\n    } else {\n      addTracks(newTracks);\n    }\n  }\n\n  function handleTextTracksPropChange(props: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    blacklistExistingSideLoadedTracks();\n    let newTracks = Array.isArray(props.textTracks) ? props.textTracks : [];\n    addTracks(newTracks);\n  }\n\n  function clear() {\n    blacklistExistingSideLoadedTracks();\n  }\n\n  function handleSelectedTextTrackChange(textTrack: ?AvailableTrack) {\n    const managedTrack = textTrack && managedTextTracks.filter(mt => mt.selectableTrack === textTrack)[0];\n    selectShakaTrack(managedTrack && managedTrack.shakaTrack);\n  }\n\n  const shakaEventHandlers = {\n    loading: emptyManagedTextTrackList,\n    trackschanged: updateFromShakaTextTracks,\n    texttrackvisibility: () => update(false)\n  };\n\n  function cleanup() {\n    emptyManagedTextTrackList();\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  return {\n    handleSelectedTextTrackChange,\n    handleTextTracksPropChange,\n    handleSourcePropChange,\n    clear,\n    cleanup\n  };\n}\n\nexport default getShakaTextTrackManager;\n"],"file":"shakaTextTrackManager.js"}